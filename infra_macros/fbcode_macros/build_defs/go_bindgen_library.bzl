load("@bazel_skylib//lib:paths.bzl", "paths")
load("@fbcode_macros//build_defs/lib:visibility.bzl", "get_visibility")
load("@fbcode_macros//build_defs:cgo_library.bzl", "cgo_library")
load("@fbcode_macros//build_defs:platform_utils.bzl", "platform_utils")
load("@fbsource//tools/build_defs:fb_native_wrapper.bzl", "fb_native")

def _gen_file_copy_rule(src):
    filename = paths.basename(src)
    name = "src-copy={}".format(filename)

    fb_native.genrule(
        name = name,
        cmd = "cp -r \$(buck root)/{} $OUT".format(src),
        out = filename,
    )
    return name

def _gen_bindgen_exe_rule(name, headers, manifest_path):
    cmd = [
        "$(exe //third-party-source/go/github.com/xlab/c-for-go:c-for-go)",
        "-out $OUT",
        "-ccincl",
        manifest_path,
    ]

    fb_native.cxx_genrule(
        name = name,
        srcs = headers + [manifest_path],
        cmd = " ".join(cmd),
        out = "go-bindgen",
    )

def _gen_header_rules(header_includes):
    parsed_headers = []

    for header in header_includes:
        if header.startswith("//"):  # we need to copy the file
            header = header.replace("//", "")

            target_name = _gen_file_copy_rule(header)

            parsed_headers.append(":" + target_name)
        else:
            parsed_headers.append(header)
    return parsed_headers

def _fix_relative_paths(src, base_path):
    if src.startswith(":"):
        loc = "$(location {})".format(src)
        src = src.split("=")[1]
    else:
        loc = base_path + "/" + src

    return " && sed -i 's@{}@'\"{}\"'@' $OUT".format(src, loc)

def _generate_bindgen_rule(
        base_path,
        name,
        package_name,
        header_includes,
        manifest):
    # parse headers (copy files prefixed with // or use the given path)
    parsed_headers = _gen_header_rules(header_includes)

    # run c-for-go bindgen generator
    bindgen_exe = "{}-go-bindgen".format(name)
    _gen_bindgen_exe_rule(
        bindgen_exe,
        parsed_headers,
        manifest,
    )

    # bindgen generated files include header files with local paths
    # this is replacing the include paths
    fix_headers = ""
    for header_target in parsed_headers:
        fix_headers += _fix_relative_paths(header_target, base_path)

    # create copy files generated by c-for-go bindgen
    cgo_headers = parsed_headers
    cgo_srcs = []
    expected_go_files = [
        package_name + ".go",
        "cgo_helpers.go",
        "types.go",
        "cgo_helpers.h",
    ]
    buck_platform = platform_utils.get_buck_platform_for_base_path(base_path)
    for filename in expected_go_files:
        genrule_name = "{}={}".format(bindgen_exe, filename)

        rule_name = ":{}#{}".format(genrule_name, buck_platform)
        cmd = "cp $(location :{})/{}/{} $OUT".format(
            bindgen_exe,
            package_name,
            filename,
        ) + fix_headers
        if filename.endswith(".go"):
            cgo_srcs.append(rule_name)

            # fix relative paths
            cmd += _fix_relative_paths(
                ":{}-go-bindgen=cgo_helpers.h".format(name),
                base_path,
            )

        elif filename.endswith(".h"):
            cgo_headers.append(rule_name)
        fb_native.cxx_genrule(
            name = genrule_name,
            cmd = cmd,
            out = filename,
        )

    return cgo_srcs, cgo_headers

def go_bindgen_library(
        name,
        package_name,
        header_includes,
        manifest,
        import_path = None,  # package_name arg equivalent in buck
        srcs = None,
        headers = None,
        go_srcs = None,
        deps = None,
        go_external_deps = None,
        preprocessor_flags = None,
        cgo_compiler_flags = None,
        linker_extra_outputs = None,
        linker_flags = None,
        link_style = None,
        visibility = None):
    srcs = srcs or []
    headers = headers or []

    extra_srcs, extra_headers = _generate_bindgen_rule(
        native.package_name(),
        name,
        package_name,
        header_includes,
        manifest,
    )

    cgo_library(
        name = name,
        package_name = import_path,
        srcs = srcs + extra_srcs,
        headers = headers + extra_headers,
        go_srcs = go_srcs,
        deps = deps,
        go_external_deps = go_external_deps,
        preprocessor_flags = preprocessor_flags,
        cgo_compiler_flags = cgo_compiler_flags,
        linker_extra_outputs = linker_extra_outputs,
        linker_flags = linker_flags,
        link_style = link_style,
        visibility = get_visibility(visibility, name),
    )
